/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 ./public/model.glb 
*/
// FILE CONTAINING ALL THE 3D ASSET ON THE GAME
import * as THREE from 'three'
import React, { useContext, useEffect, useMemo, useRef } from 'react'
import { Point, Points, Text, useAnimations, useGLTF, useTexture } from '@react-three/drei'
import { useFrame, useGraph } from '@react-three/fiber';
import { appContext } from '../src/App';
import { mobContext } from './mob_2';
import { gameAppContext } from './GameApp';
import { CustomCounter } from './utils';
import vertex from './vertex.glsl'
import frags from './frags.glsl'
import screenvertex from './screenvertex.glsl'
import screenfrags from './screenFrag.glsl'
import portal2vertex from './shaders/portal2vertex.glsl'
import portal2frags from './shaders/portal2frag.glsl'
import doorvertex from './shaders/doorVertex.glsl'
import doorfrags from './shaders/doorfrag.glsl'
import { createContext } from 'react';

export const MobModelContext = createContext();
function prepareTexture(texture)
{
  const _texture = useTexture(texture);
  _texture.flipY = false;
  _texture.colorSpace = THREE.SRGBColorSpace; 
  _texture.minFilter = THREE.LinearFilter;
  _texture.magFilter = THREE.LinearFilter;

  return _texture;
}

export function PlayerModel(props)
{
  return(
          <>
              <mesh position={[props.x,0.5,props.z]}>
                    <boxGeometry args={[0.5,0.5,0.5]} />
                    <meshBasicMaterial color={'red'} />
              </mesh>
          </>
  )
}
export function PlayerDirection(props) {
  let _appContext = useContext(appContext);
  let _gameAppContext = useContext(gameAppContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _time = 0
  let modelRef = useRef(null)
  let texture = prepareTexture('game1texture.jpg');
  let mat2 = new THREE.MeshBasicMaterial({map:texture});
  let mat3 = new THREE.ShaderMaterial({vertexShader:screenvertex,fragmentShader:screenfrags})
  let directionFront = [0,0,0];
  let directionLeft = [0,Math.PI*0.5,0];
  let directionBack = [0,Math.PI,0];
  let directionRight = [0,Math.PI*1.5,0];
  let rotationIncrementatoion = 10;
  // let turnPlayer = ()=>
  //   {
  //      if(rotationIncrementatoion <= 0)
  //      {
  //         rotationIncrementatoion = 5
  //         return true;
  //      }
  //      else
  //      {
  //         rotationIncrementatoion --; 
  //         modelRef.current.rotation.y += Math.PI*0.1;
  //         return false;
  //      }

  //   }
  // let customCounter = new CustomCounter(2,0,turnPlayer,null)

  // useEffect(()=>{customCounter.start()},[])
  useFrame(()=>
    {
      _time += 0.01
      modelRef.current.position.y += Math.sin(_time*5)/100
      // for(let i =0;i< modelRef.current.children.length;i++)
      // {
      //   if( modelRef.current.children[i].name =="player1Wheel_1" || modelRef.current.children[i].name =="player1Wheel_2" ||
      //       modelRef.current.children[i].name =="player1Wheel_3" || modelRef.current.children[i].name =="player1Wheel_4"
      //     )
      //   {
      //     if(_gameAppContext.playerMoveIsActive.current)
      //     {
      //       modelRef.current.children[i].rotation.x += 0.05
      //     }
         
      //   }
      // }
     
    })
  return (
    
      // <mesh ref={modelRef} geometry={nodes.PlayerModel1.geometry} material={mat2}  position={[0, 0.2,0]} />
      // <mesh  ref={modelRef}>
      //     <boxGeometry args={[0.5,0.5,0.5]}/>
      //     <meshBasicMaterial wireframe color={'red'} />
      // </mesh>
      // <mesh scale={1} ref={modelRef} name="player1" geometry={nodes.player1.geometry} material={mat2} position={[0, 1, 0]}>
      //       <mesh name="player1Gun" geometry={nodes.player1Gun.geometry} material={mat2} position={[0.298, 0.853, 0.861]} />
      //       <mesh name="player1Screen" geometry={nodes.player1Screen.geometry} material={mat2} />
      //       <mesh name="player1Wheel_1" geometry={nodes.player1Wheel_1.geometry} material={mat2} position={[0.388, -0.672, 0.394]} />
      //       <mesh name="player1Wheel_2" geometry={nodes.player1Wheel_2.geometry} material={mat2} position={[0.388, -0.672, -0.406]} />
      //       <mesh name="player1Wheel_3" geometry={nodes.player1Wheel_3.geometry} material={mat2} position={[-0.379, -0.672, 0.394]} rotation={[Math.PI, 0, Math.PI]} />
      //       <mesh name="player1Wheel_4" geometry={nodes.player1Wheel_4.geometry} material={mat2} position={[-0.379, -0.672, -0.406]} rotation={[Math.PI, 0, Math.PI]} />
      // </mesh>
      <mesh scale={0.9} ref={modelRef} name="playermodel2" geometry={nodes.playermodel2.geometry} material={new THREE.MeshMatcapMaterial({color:'gray'})} position={[0,1,0]}>
          <mesh name="playerHat" geometry={nodes.playerHat.geometry} material={new THREE.MeshMatcapMaterial({color:'yellow'})} position={[0, 0.273, -0.273]} />
          <mesh name="playermodel2Screen" geometry={nodes.playermodel2Screen.geometry} material={mat3} />
      </mesh>
    
  )
}
export function GroundModel(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture('alientxt.jpg');
 
  let mat = new THREE.MeshBasicMaterial({map:_texture,wireframe:false});
  let mat2 = new THREE.MeshBasicMaterial({color:'red',wireframe:true});
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.planeGround.geometry} material={mat} position={[props.x, 0, props.z]} />
    </group>
  )
}
export function BulletModel(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let modelRef = useRef(null)
  let _texture = prepareTexture('txtglobal1.jpg');
  let mat = new THREE.MeshBasicMaterial({color:'yellow',visible:props._visible,wireframe:true});

  useEffect(()=>
    { 
      props.controller.bulletModelController.value[props.controller.index] = (args)=>
      {
          if(args == 'SHOW-BULLET')
          {
            modelRef.current.children[0].material.visible = true;
          
          }
          else if(args == 'HIDE-BULLET')
          {
            modelRef.current.children[0].material.visible = false;
          }
      } 
    },[])
  return (
      <>

            <group ref={modelRef} position={[props.posX,props.posY,props.posZ]}
            >
                    {_appContext.playerStats.current.bulletModel =='default'?
                      <mesh scale={1} 
                      rotation={[Math.PI*0.5,Math.PI*0.2,0]}  
                      material={mat} geometry={nodes.bulletmodel1.geometry} >
                            <meshBasicMaterial map={_texture} visible={props._visible} />
                      </mesh>
                      :
                      _appContext.playerStats.current.bulletModel
                    }

            </group>

      </>
      
  )
}
export function PlayerCursor(props)
{
  return(<sprite 
          position={[props.x,props.y+0.05,props.z]} scale={0.015}
        >
          <spriteMaterial rotation={Math.PI*0.25} color={'white'}   />
          
        </sprite>
  )
}

export function Decor_model(props) {
  const { nodes, materials } = useGLTF('/model.glb');
  let _appContext = useContext(appContext)
  let _texture = prepareTexture(_appContext.levelInfo.current.mapTexture);
  let _texture2 = prepareTexture('txtglobal1.jpg');
  const mat3 = new THREE.MeshMatcapMaterial({map:_texture})
  const mat4 = new THREE.MeshMatcapMaterial({map:_texture2})
  
  return (

   
    <>
    {props.customModel != 'none'? 
      <>
          <group position={[props.x,0.5,props.z]} >
          {props.customModel}
          </group>
      </>
      :
      <>

          {props.skin == 'wall' && <mesh geometry={nodes.nWall.geometry} material={mat3} position={[props.x,0,props.z]}/>}
          {props.skin == 'tombstone' && <mesh geometry={nodes.tree2.geometry} material={new THREE.MeshMatcapMaterial({color:'gray'})} position={[props.x,0,props.z]}/>}
          {props.skin == 'lampadaire' && <mesh rotation={[0,Math.PI,0]}  geometry={nodes.clim.geometry} material={new THREE.MeshMatcapMaterial({color:'gray'})} position={[props.x,0,props.z]}>
                                              <mesh geometry={nodes.climfan.geometry} position={[0.003, 0.796, 0.518]} material={new THREE.MeshMatcapMaterial({color:'black'})}/>
                                        </mesh>}
      </>
    }
    </>      
      
  )
}
export function WallModel(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let _appContext = useContext(appContext);
  let _texture = prepareTexture(_appContext.levelInfo.current.mapTexture);
  let wallRef = useRef(null);
  const mat = new THREE.MeshMatcapMaterial({map:_texture})
  useEffect(()=>
    { 
      props.controller.wallController.value[props.controller.index] = (args)=>
      {
          if(args == 'SHOW-WALL')
          {
            wallRef.current.visible = true;
          }
          else if(args == 'REMOVE-WALL')
          {
            wallRef.current.visible = false;
          }
      } 
    },[])
  return(
    <mesh ref={wallRef} geometry={nodes.nWall.geometry} material={mat} position={[props.x,0,props.z]} />
  )
}
export function ItemType2Model(props) {
   //GERE LES ITEMS 3D SUR LA MAP Y COMPRIS LES ITEMS QUE LES MOBS
  let _appContext = useContext(appContext)
  let _gameAppContext = useContext(gameAppContext);
  const { nodes, materials } = useGLTF('/model.glb');
  let textureSrc;

  let _texture = prepareTexture('txtglobal1.jpg');
  let itemRef = useRef(null);
  let itemGroupRef = useRef(null)
  let containerMat = new THREE.MeshBasicMaterial({visible:false});
  let mat = new THREE.MeshBasicMaterial({map:_texture,visible:true});
  const healmat = new THREE.MeshMatcapMaterial({color:'green'});
  let mobInitialPos = {x:0,z:0};
  let bombRollDirection = useRef('NONE')
  let mobShakeAnimationStart = false
  let mobShakeFromLeft = false
  let passedTime = 0;
  const quaternionX = new THREE.Quaternion();
  const quaternionZ = new THREE.Quaternion();
  useFrame((clock)=>
  {
    if(!_appContext.gamePause.current)
    {
      if(props.objectName == 'heal_item' || props.objectName == 'coin_item' || props.objectName == 'key_item' || props.objectName == 'box_item' )
      {
        itemRef.current.rotation.y += (1/30);
      }
      else if(props.objectName == 'upgrade_life_item' || props.objectName == 'upgrade_shoot_speed_item' || props.objectName == 'upgrade_shoot_power_item')
      {
        passedTime += 1/40;
        itemRef.current.position.y += Math.sin(passedTime)/400;
      }
      else if(props.objectName == 'bomb_item')
      {
          if(_gameAppContext.objectCanMove.current.active)
          {
              if(bombRollDirection.current == 'FRONT')
              {
                quaternionX.setFromAxisAngle(new THREE.Vector3(1,0,0),0.05)
                
                itemRef.current.applyQuaternion(quaternionX)
                // itemRef.current.rotation.x += 0.05;
              }
              else if(bombRollDirection.current == 'BACK')
              {
                quaternionX.setFromAxisAngle(new THREE.Vector3(1,0,0),-0.05)
                itemRef.current.applyQuaternion(quaternionX)
                // itemRef.current.rotation.x -= 0.05;
              }
              else if(bombRollDirection.current == 'LEFT')
              {
                quaternionZ.setFromAxisAngle(new THREE.Vector3(0,0,1),-0.05)
                itemRef.current.applyQuaternion(quaternionZ)
                // itemRef.current.rotation.z -= 0.05;
              }
              else if(bombRollDirection.current == 'RIGHT')
              {
                quaternionZ.setFromAxisAngle(new THREE.Vector3(0,0,1),0.05)
                itemRef.current.applyQuaternion(quaternionZ)
                // itemRef.current.rotation.z += 0.05;
              }
          }
        
      }
    }
    
  })

  let shakeItem = ()=>
    { 
      let value = mobShakeFromLeft? -0.2 : 0.2;
      mobShakeFromLeft = mobShakeFromLeft? false : true;
      
      itemGroupRef.current.position.x = itemGroupRef.current.position.x + value
      itemGroupRef.current.position.z = itemGroupRef.current.position.z + value
      
    }
  let shakeItemCallBack = ()=>
    { 
      
      itemGroupRef.current.position.x = mobInitialPos.x
      itemGroupRef.current.position.z = mobInitialPos.z
      mobShakeAnimationStart = false;
    }
    
  useEffect(()=>
    { 
      props.controller.itemController.value[props.controller.index] = (args,params)=>
      {
          if(args == 'SHOW-ITEM')
          {
            itemGroupRef.current.visible = true;
          }
          else if(args == 'REMOVE-ITEM')
          {
            itemGroupRef.current.visible = false;
          }
          else if(args == 'MOVE-ITEM')
          {
            
            itemGroupRef.current.position.x = params.x
            itemGroupRef.current.position.z = params.z
          }
          else if(args == 'START-BOMB-COUNTER')
          {
            if(!params.objectDesc.counterStart)
            {
              params.objectDesc.counterStart = true;
              params.objectDesc.canMove = false;

              let bombCounterCallBack = ()=>
                {
                 
                  if(itemGroupRef.current.children[1].text == 1){explodeAnimation.start(); return true;}
                  else
                  {
                    itemGroupRef.current.children[1].text --;
                    
                    return false;
                  }
                  
                }
              let bombExplosion = ()=>
                {
                  if(itemGroupRef.current.children[2].scale.x >= 3.5)
                  {
                    itemGroupRef.current.children[2].scale.set(0,0,0)
                    itemGroupRef.current.children[2].visible = false;
                    params.object = false;
                    params.isOnScene = false;
                    return true;
                  }
                  else
                  {
                      itemGroupRef.current.children[0].visible = false
                      itemGroupRef.current.children[1].visible = false
                      itemGroupRef.current.children[2].visible = true
                      itemGroupRef.current.children[2].scale.set(
                      itemGroupRef.current.children[2].scale.x +0.1,
                      itemGroupRef.current.children[2].scale.y +0.1,
                      itemGroupRef.current.children[2].scale.z +0.1
                      ) 
                    
                    return false;
                  }
                }
              let explodeAnimation = new CustomCounter(1,0,bombExplosion,null);
              let bombCounter = new CustomCounter(60,0,bombCounterCallBack,null)
              bombCounter.start();
            }
            else
            {
              console.log('deja commencé')
            }
            
          }
          else if(args == 'ROLL-BOMB')
          {
            bombRollDirection.current = params
          }
          else if(args == 'ROLL-STOP')
          {
            bombRollDirection.current = "NONE"
          }
          else if(args == 'MOVE-BOMB')
          {
            if(params.direction == 'LEFT')
            {
              let objPosX =  itemGroupRef.current.position.x ;
              objPosX += params.speed
              objPosX = Math.round(objPosX * 100) / 100;
              itemGroupRef.current.position.x = objPosX
              
            }
            else if(params.direction == 'RIGHT')
            {
              let objPosX =  itemGroupRef.current.position.x ;
              objPosX -= params.speed
              objPosX = Math.round(objPosX * 100) / 100;
              itemGroupRef.current.position.x = objPosX
              
            }
            else if(params.direction == 'FRONT')
            {
              let objPosZ =  itemGroupRef.current.position.z ;
              objPosZ += params.speed
              objPosZ = Math.round(objPosZ * 100) / 100;
              itemGroupRef.current.position.z = objPosZ
              
            }
            else if(params.direction == 'BACK')
            {
              let objPosZ =  itemGroupRef.current.position.z ;
              objPosZ -= params.speed
              objPosZ = Math.round(objPosZ * 100) / 100;
              itemGroupRef.current.position.z = objPosZ
              
            }
          }
          else if(args=='SHAKE-ITEM')
          {
              if(!mobShakeAnimationStart)
              {
                // explodeParticleController.current('EXPLODE')
                mobShakeAnimationStart = true
               
                mobInitialPos.x = itemGroupRef.current.position.x;
                mobInitialPos.z = itemGroupRef.current.position.z;
                let customCounter = new CustomCounter(4,7,shakeItem,shakeItemCallBack)
                customCounter.start();
              }
          }
      } 
    },[])
  
  return (
      <>
      <group
            ref={itemGroupRef}
            visible={props._visible}
            position={[props.x,0,props.z]}
      >
          {props.skin == "bomb_item_1" && <>
                            
                                  <mesh ref={itemRef} name="bombmodel1" geometry={nodes.bombmodel1.geometry} material={new THREE.MeshMatcapMaterial({color:'gray'})} position={[0,0.5,0]}>
                                      <mesh name="bombmodel1belt" geometry={nodes.bombmodel1belt.geometry} material={new THREE.MeshMatcapMaterial({color:'red'})} />
                                      <mesh name="bombmodel1head" geometry={nodes.bombmodel1head.geometry} material={new THREE.MeshMatcapMaterial({color:'red'})} />
                                  </mesh>
                                  <Text
                                      
                                      characters='1234567890'
                                      fontSize={0.8} fontWeight={700}
                                      rotation={[0,-(Math.PI),0]}
                                      position={[0,1.5,0]} color={'white'} anchorX={"center"} anchorY={"middle"}
                                  >
                                         {props.timer}
                                  </Text>
                                  <mesh visible={false} scale={1} position={[0,0.5,0]}>
                                        <sphereGeometry args={[0.9,20,20]} />
                                        <meshBasicMaterial color={'red'} />
                                  </mesh>
                            
            </>}
          {props.skin == "battery_item_1" && <>
                          
            <mesh geometry={nodes.battery.geometry} material={new THREE.MeshMatcapMaterial({color:'gray'})} >
              <mesh geometry={nodes.batteryHead.geometry} material={new THREE.MeshMatcapMaterial({color:'white'})} position={[0, 1.5, 0]} />
            </mesh>
                          
                      
          </>}
          {props.skin == "coin_item_1" && <>
                                    <group ref={itemRef} >
                                          {props.customModel}
                                    </group>
                                    <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'green'} _speed={1} _number={30} x={0} z={0} />
                                </>}
          {props.skin == "coin_item_2" && <>
              <group ref={itemRef} >
                    {props.customModel == "none"?
                        <>
                            <mesh  scale={0.5} geometry={nodes.coinmodel1.geometry} position={[0,0.5,0]}>
                                <meshMatcapMaterial color={'gold'} />
                            </mesh>
                        </>
                    :
                        <>
                          {props.customModel}
                        </>
                    }
              </group>
              <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'green'} _speed={1} _number={30} x={0} z={0} />
          </>}
          {props.skin == "heal_item_1" && <>
                                              <group ref={itemRef} >
                                                  {props.customModel!='none'?
                                                    <>
                                                          {props.customModel}
                                                    </>
                                                    :
                                                    <>
                                                          <mesh  scale={0.5} geometry={nodes.pheal_1.geometry} material={healmat} position={[0,0.1,0]} />
                                                    </>
                                                  }
                                              </group>
                                              <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'green'} _speed={1} _number={30} x={0} z={0} />
                                          </>}
          {props.skin == "key_1" && <>  
                                        <group ref={itemRef}>
                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh scale={1} rotation={[Math.PI*0.5,0,0]} geometry={nodes.key2.geometry} material={new THREE.MeshMatcapMaterial({color:'silver'})} position={[0,0.8,0]} />
                                              </>
                                            }
                                        </group>
                                        <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                    </>
          }
          {props.skin == "key_2" && <>  
                                        <group ref={itemRef}>
                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh scale={0.5} rotation={[Math.PI*0.5,0,Math.PI*0.2]} name="key2" geometry={nodes.key2.geometry} material={mat} position={[0,0.5, 0]} />
                                              </>
                                            }
                                        </group>
                                        <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                    </>
          }
          {props.skin == "box_1" && <group  ref={itemRef}>
                                            
                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh scale={1} geometry={nodes.crate_1.geometry} material={mat} position={[0,0.8,0]} /> 
                                              </>
                                            } 
                                    </group>
          }
          {props.skin == "upgrade_shoot_speed_item" && 
                                            <>
                                            <group ref={itemRef}>

                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh
                                                
                                                position={[0,0.5,0]}
                                                >
                                                    <sphereGeometry args={[0.2,10,10]} />
                                                    <meshMatcapMaterial color={'blue'} />
                                                </mesh> 
                                              </>
                                            }

                                          
                                          </group>
                                          <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                          </>
          }
          {props.skin == "upgrade_shoot_power_item" && <>
                                                        <group ref={itemRef}>
                                                        
                                                              {props.customModel!='none'?
                                                                <>
                                                                  {props.customModel}
                                                                </>
                                                                :
                                                                <>
                                                                  <mesh
                                                                    
                                                                    position={[0,0.5,0]}
                                                                    >
                                                                        <sphereGeometry args={[0.2,10,10]} />
                                                                        <meshMatcapMaterial color={'red'} />
                                                                  </mesh> 
                                                                </>
                                                              }
                                                      </group>
                                                      <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                                      </>
          }
          {props.skin == "upgrade_life_item" && <>
                                            <group ref={itemRef}>

                                                      {props.customModel!='none'?
                                                        <>
                                                          {props.customModel}
                                                        </>
                                                        :
                                                        <>
                                                          <mesh
                                                
                                                                position={[0,0.5,0]}
                                                                >
                                                                    <sphereGeometry args={[0.2,10,10]} />
                                                                    <meshMatcapMaterial color={'green'} />
                                                          </mesh> 
                                                        </>
                                                      }
                                            
                                            
                                          </group>
                                          <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                          </>
          }
          
          {props.skin == "wall_1" && <mesh ref={itemRef}  geometry={nodes.wall_1.geometry} material={mat} position={[0,0,0]}/>}
      </group>
      
      </>
            
      
  )
}

export function ItemType1Model(props)
{
  //GERE LES UTEMS SPRITE SUR LA MAP Y COMPRIS LES ITEMS QUE LES MOBS
  let _appContext = useContext(appContext)
  let paticleTexture;
  let spriteRef = useRef(null);
  let passedTime = 0;

  if(props.skin == 'coin_item_1')
  {
    paticleTexture = useTexture('coin.svg');
  }

  useEffect(()=>
    { 
      
      props.controller.itemController.value[props.controller.index] = (args,params)=>
      {
       
          if(args == 'SHOW-ITEM')
          {
              spriteRef.current.visible = true;
          }
          else if(args == 'REMOVE-ITEM')
          {
              spriteRef.current.visible = false;
          }
          else if(args == 'MOVE-ITEM')
          {
            
            spriteRef.current.position.x = params.x
            spriteRef.current.position.z = params.z
          }
      } 
    },[])
  useFrame((clock)=>
    {
        if(!_appContext.gamePause.current)
        {passedTime += 1/40;
        spriteRef.current.children[0].position.y += Math.sin(passedTime)/400;}
    })
  return(     <>
              <group ref={spriteRef} visible={props._visible} position={[props.x,0.5,props.z]} >
                    <sprite 
                      position={[0,0,0]} scale={[0.4,0.4,1]}
                    >
                      <spriteMaterial map={paticleTexture}   />
                      
                    </sprite>
                    <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'}  _speed={1} _number={15} x={0} z={0} />
              </group>
              </>
  )
}
function CustomParticle(props)
{
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let paticleTexture = useTexture(`particleRes/${props._skin}`);
  let objRef = useRef(null);
  let pointRef = useRef(null)
  let particlesContainer =[];
  let particlesInfo = [];

      for(let i =0;i<props._number;i++)
      {
        particlesInfo[i] = {start:false,timer:Math.floor(Math.random()*80),limit:1.1}
        particlesInfo[i].start = particlesInfo[i].timer ==0? true : false
        particlesContainer[i] = <sprite key={i} 
                                  position={[(Math.random()*0.9)-0.5
                                    ,0
                                    ,(Math.random()*0.9)-0.5]} scale={Math.random()*props._size}
                                >
                                  <spriteMaterial visible={false} color={props._color} alphaMap={paticleTexture} depthWrite={true}  />
                                </sprite>
      }  
  
  useFrame(()=>
    { 
      if(!_appContext.gamePause.current)
      
      {
          for(let i =0;i<pointRef.current.children.length;i++)
          {
            if(particlesInfo[i].start)
            {
              pointRef.current.children[i].position.y += 0.01*props._speed;
              pointRef.current.children[i].material.visible = true
              if(pointRef.current.children[i].position.y >= particlesInfo[i].limit )
              {
                particlesInfo[i].start = false;
                particlesInfo[i].timer = Math.floor(Math.random()*80);
                let scaleValue = Math.random()*props._size
                pointRef.current.children[i].scale.set(scaleValue,scaleValue,scaleValue)
                pointRef.current.children[i].material.visible = false;
                pointRef.current.children[i].position.y = 0;
              }
              
            }
            else
            {
              particlesInfo[i].timer --;
              if(particlesInfo[i].timer<=0)
              {
                particlesInfo[i].start = true;
              }
            }
            
          }
      }
      
    })
  return(
        <group
          name='PARTICLE GROUP CONTAINER'
          position={[props.x,0.2,props.z]}
          ref={pointRef}
        >
            {particlesContainer}
        </group>
  )
}

export function ExitDoor_model(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let texturemat = prepareTexture('txtglobal1.jpg');
  let exitDoorShaderRef = useRef(null);

let mat = new THREE.ShaderMaterial({visible:false,side:THREE.DoubleSide,vertexShader:doorvertex,fragmentShader:doorfrags,uniforms:{utime:{value:0}},transparent:true})
  // useFrame((clock)=>{
  //   faceRef.current.material.uniforms.utime.value += 0.05;

  // })

  useEffect(()=>
    { 
      if(props.isOpen)
      {
        // faceRef.current.material.uniforms.uColor.value.x = 0.0;
        // faceRef.current.material.uniforms.uColor.value.z = 1.0;
      }
      props.controller.exitDoorController.value[props.controller.index] = (args)=>
      {
          if(args == 'OPEN-DOOR')
          {
            exitDoorShaderRef.current.material.visible = true;
            // let openDoorFunc = ()=>
            // {
            //   if(exitDoorShaderRef.current.position.y>=2)
            //   {
            //     return true;
            //   }
            //   else
            //   {
            //     exitDoorShaderRef.current.position.y += 0.05;
            //     return false;
            //   }
            // }
            // // faceRef.current.material.uniforms.uColor.value.x = 0.0;
            // // faceRef.current.material.uniforms.uColor.value.z = 1.0;
            // let doorOpenAnimation = new CustomCounter(1,0,openDoorFunc,null)
            // doorOpenAnimation.start();
          }
      } 
    },[])
  useFrame(()=>
    {
      exitDoorShaderRef.current.material.uniforms.utime.value += 0.01;
    })
  return(
    
    <mesh geometry={nodes.exit2.geometry} rotation={[0,0,0]} material={new THREE.MeshMatcapMaterial({color:'cyan'})} position={[props.x,0,props.z]} >
        <mesh ref={exitDoorShaderRef} geometry={nodes.exit2shad.geometry} material={mat} position={[0, 1.047, 0]} />
    </mesh>

    
  )
}

export function Mob_1_model(props) {

  const group = React.useRef()
  const { nodes, materials, animations } = useGLTF('/model.glb')
  const { mixer,actions } = useAnimations(animations, group)
  
  let _appContext = useContext(appContext);
  let _mobContext = useContext(props._context);
  const mat = new THREE.MeshMatcapMaterial({color:'red',transparent:true})
  let modelRef = useRef(null);
  let mobHitManager = {startEffect:false,timer:10,effectCount:0}
  let passedTime = 0;
  let mobShakeFromLeft = false;
  let mobInitialPos = 0;
  let mobShakeAnimationStart = false;
  let explodeParticleController = useRef(null); 
  let shakeOrientation = useRef('FRONT-BACK');
  let animationManager = useRef({start:false});
  let handRef = useRef(null);
  let customMobController = useRef(null);
  let shakeBrick = ()=>
    { 
      let value = mobShakeFromLeft? -0.2 : 0.2;
      mobShakeFromLeft = mobShakeFromLeft? false : true;
      if(shakeOrientation.current == 'FRONT-BACK')
      {
        modelRef.current.position.x = modelRef.current.position.x + value
      }
      else
      {
        modelRef.current.position.z = modelRef.current.position.z + value
      }
      
    }
  let shakeBrickCallBack = ()=>
    { 
      
      if(shakeOrientation.current == 'FRONT-BACK')
      {modelRef.current.position.x = mobInitialPos}
      else
      {modelRef.current.position.z = mobInitialPos}
      mobShakeAnimationStart = false;
    }
  useFrame(()=>
    {
      if(!_appContext.gamePause.current)
      { 
        if(animationManager.current.start)
        {
            if(actions.m_mob1attack2?.time >= 0.4)
            {
              animationManager.current.start = false;
              _mobContext.mobShootAnimationOver.current = true;
            }
            if(actions.m_mob1dead1?.time >= 0.3)
            {
             
              actions.m_mob1dead1.paused = true;
              actions.m_mob1dead2.paused = true;
              actions.m_mob1dead3.paused = true;
              actions.m_mob1dead4.paused = true;
              actions.m_mob1dead5.paused = true;
              animationManager.current.start = false;
            }
        }

        passedTime += 1/40;
        modelRef.current.position.y += Math.sin(passedTime)/400;

        if(mobHitManager.startEffect)
          {
            mobHitManager.timer--;
            if(mobHitManager.timer == 0)
            {
              mobHitManager.effectCount ++;
              mobHitManager.timer = 10;
              
              if(mobHitManager.effectCount<7)
              { 
                modelRef.current.children[0].visible = modelRef.current.children[0].visible? false : true;
              }
              else
              {
                mobHitManager.effectCount = 0;
                mobHitManager.startEffect = false;
                modelRef.current.children[0].visible = false;
              }
              
            }
          }
      }
    })
    let mobAttackAnime = ()=>
      {
        animationManager.current.start = true;
        actions.m_mob1attack1?.play();
        actions.m_mob1attack2?.play();
        actions.m_mob1attack3?.play();
        actions.m_mob1attack4?.play();
        actions.m_mob1attack5?.play();
      }

  useEffect(()=>
    {
      if(props.customModel == 'none')
      {
        actions.m_mob1attack1?.setLoop(THREE.LoopOnce,1);
        actions.m_mob1attack2?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1attack3?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1attack4?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1attack5?.setLoop(THREE.LoopOnce,1)
  
        actions.m_mob1dead1?.setLoop(THREE.LoopOnce,1);
        actions.m_mob1dead2?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1dead3?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1dead4?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1dead5?.setLoop(THREE.LoopOnce,1)
      }


      mixer.addEventListener('finished', function( e ) 
      {
        if(e.action._clip.name == "m_mob1attack2")
        {
          actions.m_mob1attack1?.stop();
          actions.m_mob1attack2?.stop();
          actions.m_mob1attack3?.stop();
          actions.m_mob1attack4?.stop();
          actions.m_mob1attack5?.stop();
          
        }
        else if(e.action._clip.name == "m_mob1dead1")
        {
          actions.m_mob1dead1?.stop();
          actions.m_mob1dead2?.stop();
          actions.m_mob1dead3?.stop();
          actions.m_mob1dead4?.stop();
          actions.m_mob1dead5?.stop();
          
        }

        
      } )
        
    },[])
  useEffect(()=>
    {
      /**
       * 
       * @param {string} args 
       * @param {object|undefined} params 
       */
      _mobContext.enemyController.current = (args,params)=>
        {
          if(args == 'REMOVE-MOB')
          {
            modelRef.current.visible = false;
          }
          else if(args == 'MOVE-MOB')
          {
            modelRef.current.position.x = params.x
            modelRef.current.position.z = params.z
          }
          else if(args == 'MOB-TOUCHED')
          { 
            if(!mobShakeAnimationStart)
            {
              explodeParticleController.current('EXPLODE')
              mobShakeAnimationStart = true
             
              if(shakeOrientation.current == 'FRONT-BACK')
              {mobInitialPos = modelRef.current.position.x;}
              else
              {mobInitialPos = modelRef.current.position.z;}
              let customCounter = new CustomCounter(4,7,shakeBrick,shakeBrickCallBack)
              customCounter.start();
            }

          }
          else if(args == 'MOB-ROTATE-LEFT')
          {
            shakeOrientation.current = 'LEFT-RIGHT'
            modelRef.current.rotation.y = Math.PI*0.5
          }
          else if(args == 'MOB-ROTATE-RIGHT')
          {
            shakeOrientation.current = 'LEFT-RIGHT'
            modelRef.current.rotation.y = -Math.PI*0.5
          }
          else if(args == 'MOB-ROTATE-FRONT')
          {
            shakeOrientation.current = 'FRONT-BACK'
            modelRef.current.rotation.y = 0
          }
          else if(args == 'MOB-ROTATE-BACK')
          {
            shakeOrientation.current = 'FRONT-BACK'
            modelRef.current.rotation.y = Math.PI
          }
          else if(args == 'PLAY-MOB-ATTACK-ANIMATION')
          {
            if(props.customModel == 'none')
            {
              mobAttackAnime()
            }
          
          }
          else if(args == 'PLAY-MOB-DEAD-ANIMATION')
          { 
            
            if(props.customModel == 'none')
            {
                let customCounter = new CustomCounter(5,0,()=>
                  {
                    
                      handRef.current.material.opacity -=0.1;
                      if(handRef.current.material.opacity<=0)
                        {
                            modelRef.current.visible = false;
                            params()
                            return true
                        }
                      else
                      {
                            return false
                      }
                    
                    
                  },null)
                  customCounter.start();
            }
            else
            {
              customMobController.current('REMOVE-MOB');
              params();
            }
            
            
          }
        }
    },[])
  
  return (

        

          <>  <MobModelContext.Provider value={{customMobController}}>
                    <group ref={group} {...props} dispose={null}>
                    <mesh ref={modelRef} position={[props.x,0.8,props.z]} rotation={[0,Math.PI, 0]} >
                            <boxGeometry args={[2,2,2]} />
                            <meshBasicMaterial color={'red'} visible={false} wireframe />
                            <MobHitParticleEffect controller={explodeParticleController} x={0.5} z={0.5} />
                            {/* MOB MODEL */}
                            {props.customModel == 'none'?
                              <>
                                  <mesh name="nmob1" geometry={nodes.nmob1.geometry} material={new THREE.MeshMatcapMaterial({color:'black'})} >
                                    <mesh ref={handRef} name="nmob1_hand_l" geometry={nodes.nmob1_hand_l.geometry} material={mat} position={[0.639, -0.473, -0.066]} />
                                    <mesh name="nmob1_hand_r" geometry={nodes.nmob1_hand_r.geometry} material={mat} position={[-0.639, -0.494, 0]} />
                                    <mesh name="nmob1head" geometry={nodes.nmob1head.geometry} material={new THREE.MeshMatcapMaterial({color:'white'})} />
                                    <mesh name="nmob1horn" geometry={nodes.nmob1horn.geometry} material={mat} />
                                  </mesh>
                              </>
                              :
                              <>
                              <group ref={handRef}>
                                  {props.customModel}
                              </group>
                              
                              </>
                            }
                            

                    </mesh>
                    
                    <mesh position={[props.x,0.1,props.z]} visible={false}
                    >
                        <boxGeometry args={[2,2,2]}  />
                        <meshBasicMaterial wireframe color={'red'} />
                        <BulletCollisionEffect />
                    </mesh>
                    </group>
              </MobModelContext.Provider>
          </>
         
            
      
  )
}
function MobHitParticleEffect(props)
{
  let paticleTexture = useTexture('particleRes/fire_01.png')
  let spriteGroupRef = useRef(null)
  let ref1 = useRef(null)
  let ref2 = useRef(null)
  let ref3 = useRef(null)
  let ref4 = useRef(null)
  let explodeSeepd = 0.03
  let explodeStart = useRef(false);
  let spriteMat = <spriteMaterial color={'red'} alphaMap={paticleTexture} depthWrite={true}  />;
  useFrame(()=>
    {
      if(explodeStart.current)
      {
        ref1.current.position.x += explodeSeepd
        ref1.current.position.y += explodeSeepd
        ref2.current.position.x -= explodeSeepd
        ref2.current.position.y += explodeSeepd

        ref3.current.position.x += explodeSeepd
        ref3.current.position.y -= explodeSeepd
        ref4.current.position.x -= explodeSeepd
        ref4.current.position.y -= explodeSeepd
        
        if(ref1.current.position.x >= 0.5)
        {
          explodeStart.current = false;
          spriteGroupRef.current.visible = false;
          ref1.current.position.x = 0
          ref1.current.position.y = 0.2
          ref2.current.position.x = -0.2
          ref2.current.position.y = 0.2

          ref3.current.position.x = 0
          ref3.current.position.y = 0
          ref4.current.position.x = -0.2
          ref4.current.position.y = 0
        }
      }
        
    })

  useEffect(()=>
    {
      props.controller.current = (args)=>
        {
          if(args == 'EXPLODE')
          {
            spriteGroupRef.current.visible = true;
            explodeStart.current = true;
          }
        }  
    },[])
  return(
    <>
        <group
         ref={spriteGroupRef} visible={false}
        >
                <sprite 
                  ref={ref1}
                  position={[0,0.2,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>
                <sprite 
                  ref={ref2}
                  position={[-0.2,0.2,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>

                <sprite 
                  ref={ref3}
                  position={[0,0,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>
                <sprite 
                  ref={ref4}
                  position={[-0.2,0,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>
        </group>
        
        
    </>
    
    
  )
}


export function Barier_Model(props)
{
  let _gameAppContext = useContext(gameAppContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture('txtglobal1.jpg');
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  let particleGroupRef = useRef(null)
  let modelRef = useRef(null);
  let planeRef = useRef(null);

  let modelFunc = (args)=>
      {
          if(args == "hide")
          { 

            
              particleGroupRef.current.visible = true;
              let customCounter = new CustomCounter(100,0,()=>
                {
                   
                    if(props.customModel == 'none')
                    {
                      modelRef.current.material.visible = false;
                      planeRef.current.material.visible = false;
                    }
                    else
                    {
                      modelRef.current.visible = false;
                    }
                   
                   particleGroupRef.current.visible = false;
                   return true;
                },null);
              
              customCounter.start();
            

            
          }
      }
  let mat2 = new THREE.ShaderMaterial( {
    uniforms: THREE.UniformsUtils.merge( [
        THREE.UniformsLib[ 'fog' ],{utime:{value:0.2},uColor:{value:new THREE.Vector3(1,0,0)}}] ),
      vertexShader: vertex,
      fragmentShader: frags,
      fog: true,
      transparent:true,
      side:THREE.DoubleSide
    } );
  useFrame((clock)=>{

    if (props.customModel == 'none')
    {
      planeRef.current.material.uniforms.utime.value += 0.02;
    }  
      

  })
  useEffect(()=>
    {

        for(let i =0;i<_gameAppContext.barierModelIndexArr.value.length;i++)
          {
            if(_gameAppContext.barierModelIndexArr.value[i].objectId == props.refID)
            {
              _gameAppContext.barierModelIndexArr.value[i].modelController = modelFunc;
            }
          }
      
      
      
    },[])
  
  return(     <>
                     {props.customModel == 'none'?
                      <mesh ref={modelRef} name="nbarrier" geometry={nodes.barrier.geometry} material={new THREE.MeshMatcapMaterial({color:'gray'})} position={[props.x,0,props.z]} >
                          <mesh ref={planeRef} name="nbarrierplane" geometry={nodes.barrierShad.geometry} material={mat2} position={[0, 1.048, 0]} />
                      </mesh>
                      :
                      <group ref={modelRef} position={[props.x,0,props.z]} rotation={[0,(props.orientation == 'FRONT'?0:Math.PI*0.5),0]}>
                        {props.customModel}
                      </group>
                     }
                    
                    <group
                          ref={particleGroupRef}
                          visible={false}
                    >
                        <CustomParticle _skin={'smoke_06.png'} _size={1.5} _color={'white'} _speed={3} _number={10} x={props.x} z={props.z} />
                    </group>
              
              </>
  )
}
export function EnemyBullet(props)
{
  let bulletTXT = useTexture('ennemyBulletTxt.png');
  bulletTXT.flipY = false;
  bulletTXT.colorSpace = THREE.SRGBColorSpace; 
  bulletTXT.minFilter = THREE.LinearFilter;
  bulletTXT.magFilter = THREE.LinearFilter;

  return(
          <>
                   <mesh
                        key={props._i}
                        ref={props._ref}
                        position={props._position}
                    >
                        <sphereGeometry args={[0.2,10,10]} />
                        <meshBasicMaterial visible={false} map={bulletTXT} />
                    </mesh>
          </>
  )
}

export function BulletCollisionEffect(props)
{
  return(
    <>
    <sprite 
    position={[0
      ,1
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    <sprite 
    position={[0.16
      ,1
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    <sprite 
    position={[0
      ,0.85
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    <sprite 
    position={[0.16
      ,0.85
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    </>
  )
}
export function BallPortalModel(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let _appContext = useContext(appContext);
  let portalRef = useRef(null);
  const mat = new THREE.MeshMatcapMaterial({color:'gray'})
  let partalShaders = new THREE.ShaderMaterial({transparent:true,side:THREE.DoubleSide,vertexShader:portal2vertex,fragmentShader:portal2frags,uniforms:{utime:{value:0}}})
  let _utime = 0;
  useFrame(()=>
  {
    _utime += 0.01;
    partalShaders.uniforms.utime.value = _utime;
  })
  useEffect(()=>
    { 
      
    },[])
  return(
    <mesh ref={portalRef}  geometry={nodes.portal_2.geometry} material={mat} position={[props.x,2.2,props.z]}>
            <mesh geometry={nodes.portal_2_glass.geometry} material={partalShaders} position={[0, -0.839, 0]} ></mesh>
    </mesh>
  )
}
useGLTF.preload('/model.glb')
