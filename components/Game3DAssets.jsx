/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 ./public/model.glb 
*/
// FILE CONTAINING ALL THE 3D ASSET ON THE GAME
import * as THREE from 'three'
import React, { useContext, useEffect, useMemo, useRef } from 'react'
import { Point, Points, useAnimations, useGLTF, useTexture } from '@react-three/drei'
import { useFrame, useGraph } from '@react-three/fiber';
import { appContext } from '../src/App';
import { mobContext } from './mob_2';
import { gameAppContext } from './GameApp';
import { CustomCounter } from './utils';
import vertex from './vertex.glsl'
import frags from './frags.glsl'
import { createContext } from 'react';

export const MobModelContext = createContext();
function prepareTexture(texture)
{
  const _texture = useTexture(texture);
  _texture.flipY = false;
  _texture.colorSpace = THREE.SRGBColorSpace; 
  _texture.minFilter = THREE.LinearFilter;
  _texture.magFilter = THREE.LinearFilter;

  return _texture;
}

export function PlayerModel(props)
{
  return(
          <>
              <mesh position={[props.x,0.5,props.z]}>
                    <boxGeometry args={[0.5,0.5,0.5]} />
                    <meshBasicMaterial color={'red'} />
              </mesh>
          </>
  )
}
export function PlayerDirection(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
 
  let modelRef = useRef(null)
  let mat2 = new THREE.MeshBasicMaterial({color:'white',wireframe:true});
  let directionFront = [0,0,0];
  let directionLeft = [0,Math.PI*0.5,0];
  let directionBack = [0,Math.PI,0];
  let directionRight = [0,Math.PI*1.5,0];
  let rotationIncrementatoion = 10;
  // let turnPlayer = ()=>
  //   {
  //      if(rotationIncrementatoion <= 0)
  //      {
  //         rotationIncrementatoion = 5
  //         return true;
  //      }
  //      else
  //      {
  //         rotationIncrementatoion --; 
  //         modelRef.current.rotation.y += Math.PI*0.1;
  //         return false;
  //      }

  //   }
  // let customCounter = new CustomCounter(2,0,turnPlayer,null)

  // useEffect(()=>{customCounter.start()},[])
  return (
    
      <mesh ref={modelRef} geometry={nodes.playerDirection.geometry} material={mat2}  position={[0, 0.2,0]} />
    
  )
}
export function GroundModel(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture(_appContext.levelInfo.current.mapTexture);
 
  let mat = new THREE.MeshBasicMaterial({map:_texture,wireframe:true});
  let mat2 = new THREE.MeshBasicMaterial({color:'red',wireframe:true});
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.planeGround.geometry} material={mat2} position={[props.x, 0, props.z]} />
    </group>
  )
}
export function BulletModel(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let modelRef = useRef(null)
  let _texture = prepareTexture('txtglobal1.jpg');
  let mat = new THREE.MeshBasicMaterial({color:'yellow',visible:props._visible,wireframe:true});

  useEffect(()=>
    { 
      props.controller.bulletModelController.value[props.controller.index] = (args)=>
      {
          if(args == 'SHOW-BULLET')
          {
            modelRef.current.children[0].material.visible = true;
          
          }
          else if(args == 'HIDE-BULLET')
          {
            modelRef.current.children[0].material.visible = false;
          }
      } 
    },[])
  return (
      <>

            <group ref={modelRef} position={[props.posX,props.posY,props.posZ]}
            >
                    {_appContext.playerStats.current.bulletModel =='default'?
                      <mesh scale={1} 
                      rotation={[Math.PI*0.5,Math.PI*0.2,0]}  
                      material={mat} geometry={nodes.nArrow.geometry} >
                            <meshBasicMaterial map={_texture} visible={props._visible} />
                      </mesh>
                      :
                      _appContext.playerStats.current.bulletModel
                    }

            </group>

      </>
      
  )
}
export function PlayerCursor(props)
{
  return(<sprite 
          position={[props.x,props.y+0.05,props.z]} scale={0.015}
        >
          <spriteMaterial rotation={Math.PI*0.25} color={'white'}   />
          
        </sprite>
  )
}

export function Decor_model(props) {
  const { nodes, materials } = useGLTF('/model.glb');
  let _appContext = useContext(appContext)
  let _texture = prepareTexture(_appContext.levelInfo.current.mapTexture);
  let _texture2 = prepareTexture('txtglobal1.jpg');
  const mat3 = new THREE.MeshMatcapMaterial({map:_texture})
  const mat4 = new THREE.MeshMatcapMaterial({map:_texture2})
  
  return (

   
    <>
    {props.customModel != 'none'? 
      <>
          <group position={[props.x,0.5,props.z]} >
          {props.customModel}
          </group>
      </>
      :
      <>

          {props.skin == 'wall' && <mesh geometry={nodes.nWall.geometry} material={mat3} position={[props.x,0,props.z]}/>}
          {props.skin == 'tombstone' && <mesh geometry={nodes.ndecor1.geometry} material={mat4} position={[props.x,0,props.z]}/>}
          {props.skin == 'lampadaire' && <mesh geometry={nodes.ndecor2.geometry} material={mat4} position={[props.x,0,props.z]}/>}
      </>
    }
    </>      
      
  )
}
export function WallModel(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let _appContext = useContext(appContext);
  let _texture = prepareTexture(_appContext.levelInfo.current.mapTexture);
  let wallRef = useRef(null);
  const mat = new THREE.MeshMatcapMaterial({map:_texture})
  useEffect(()=>
    { 
      props.controller.wallController.value[props.controller.index] = (args)=>
      {
          if(args == 'SHOW-WALL')
          {
            wallRef.current.visible = true;
          }
          else if(args == 'REMOVE-WALL')
          {
            wallRef.current.visible = false;
          }
      } 
    },[])
  return(
    <mesh ref={wallRef} geometry={nodes.nWall.geometry} material={mat} position={[props.x,0,props.z]} />
  )
}
export function ItemType2Model(props) {
   //GERE LES ITEMS 3D SUR LA MAP Y COMPRIS LES ITEMS QUE LES MOBS
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let textureSrc;

  let _texture = prepareTexture('txtglobal1.jpg');
  let itemRef = useRef(null);
  let itemGroupRef = useRef(null)
  let containerMat = new THREE.MeshBasicMaterial({visible:false});
  let mat = new THREE.MeshBasicMaterial({map:_texture,visible:true});
  const healmat = new THREE.MeshMatcapMaterial({color:'green'});
  let mobInitialPos = {x:0,z:0};
  let mobShakeAnimationStart = false
  let mobShakeFromLeft = false
  let passedTime = 0;
  useFrame((clock)=>
  {
    if(!_appContext.gamePause.current)
    {
      if(props.objectName == 'heal_item' || props.objectName == 'key_item' || props.objectName == 'box_item' )
      {
        itemRef.current.rotation.y += (1/30);
      }
      else if(props.objectName == 'upgrade_life_item' || props.objectName == 'upgrade_shoot_speed_item' || props.objectName == 'upgrade_shoot_power_item')
      {
        passedTime += 1/40;
        itemRef.current.position.y += Math.sin(passedTime)/400;
      }
    }
    
  })

  let shakeItem = ()=>
    { 
      let value = mobShakeFromLeft? -0.2 : 0.2;
      mobShakeFromLeft = mobShakeFromLeft? false : true;
      
      itemGroupRef.current.position.x = itemGroupRef.current.position.x + value
      itemGroupRef.current.position.z = itemGroupRef.current.position.z + value
      
    }
  let shakeItemCallBack = ()=>
    { 
      
      itemGroupRef.current.position.x = mobInitialPos.x
      itemGroupRef.current.position.z = mobInitialPos.z
      mobShakeAnimationStart = false;
    }
    
  useEffect(()=>
    { 
      props.controller.itemController.value[props.controller.index] = (args,params)=>
      {
          if(args == 'SHOW-ITEM')
          {
            itemGroupRef.current.visible = true;
          }
          else if(args == 'REMOVE-ITEM')
          {
            itemGroupRef.current.visible = false;
          }
          else if(args == 'MOVE-ITEM')
          {
            
            itemGroupRef.current.position.x = params.x
            itemGroupRef.current.position.z = params.z
          }
          else if(args=='SHAKE-ITEM')
          {
              if(!mobShakeAnimationStart)
              {
                // explodeParticleController.current('EXPLODE')
                mobShakeAnimationStart = true
               
                mobInitialPos.x = itemGroupRef.current.position.x;
                mobInitialPos.z = itemGroupRef.current.position.z;
                let customCounter = new CustomCounter(4,7,shakeItem,shakeItemCallBack)
                customCounter.start();
              }
          }
      } 
    },[])
  
  return (
      <>
      <group
            ref={itemGroupRef}
            visible={props._visible}
            position={[props.x,0,props.z]}
      >
          {props.skin == "coin_item_1" && <>
                                    <group ref={itemRef} >
                                          {props.customModel}
                                    </group>
                                    <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'green'} _speed={1} _number={30} x={0} z={0} />
                                </>}
          {props.skin == "heal_item_1" && <>
                                              <group ref={itemRef} >
                                                  {props.customModel!='none'?
                                                    <>
                                                          {props.customModel}
                                                    </>
                                                    :
                                                    <>
                                                          <mesh  scale={0.5} geometry={nodes.pheal_1.geometry} material={healmat} position={[0,0.1,0]} />
                                                    </>
                                                  }
                                              </group>
                                              <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'green'} _speed={1} _number={30} x={0} z={0} />
                                          </>}
          {props.skin == "key_1" && <>  
                                        <group ref={itemRef}>
                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh scale={0.5} rotation={[0,0,Math.PI*0.2]} geometry={nodes.key_1.geometry} material={mat} position={[0,0.8,0]} />
                                              </>
                                            }
                                        </group>
                                        <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                    </>
          }
          {props.skin == "key_2" && <>  
                                        <group ref={itemRef}>
                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh scale={0.5} rotation={[Math.PI*0.5,0,Math.PI*0.2]} name="key2" geometry={nodes.key2.geometry} material={mat} position={[0,0.5, 0]} />
                                              </>
                                            }
                                        </group>
                                        <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                    </>
          }
          {props.skin == "box_1" && <group  ref={itemRef}>
                                            
                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh scale={1} geometry={nodes.crate_1.geometry} material={mat} position={[0,0.8,0]} /> 
                                              </>
                                            } 
                                    </group>
          }
          {props.skin == "upgrade_shoot_speed_item" && 
                                            <>
                                            <group ref={itemRef}>

                                            {props.customModel!='none'?
                                              <>
                                                {props.customModel}
                                              </>
                                              :
                                              <>
                                                <mesh
                                                
                                                position={[0,0.5,0]}
                                                >
                                                    <sphereGeometry args={[0.2,10,10]} />
                                                    <meshMatcapMaterial color={'blue'} />
                                                </mesh> 
                                              </>
                                            }

                                          
                                          </group>
                                          <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                          </>
          }
          {props.skin == "upgrade_shoot_power_item" && <>
                                                        <group ref={itemRef}>
                                                        
                                                              {props.customModel!='none'?
                                                                <>
                                                                  {props.customModel}
                                                                </>
                                                                :
                                                                <>
                                                                  <mesh
                                                                    
                                                                    position={[0,0.5,0]}
                                                                    >
                                                                        <sphereGeometry args={[0.2,10,10]} />
                                                                        <meshMatcapMaterial color={'red'} />
                                                                  </mesh> 
                                                                </>
                                                              }
                                                      </group>
                                                      <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                                      </>
          }
          {props.skin == "upgrade_life_item" && <>
                                            <group ref={itemRef}>

                                                      {props.customModel!='none'?
                                                        <>
                                                          {props.customModel}
                                                        </>
                                                        :
                                                        <>
                                                          <mesh
                                                
                                                                position={[0,0.5,0]}
                                                                >
                                                                    <sphereGeometry args={[0.2,10,10]} />
                                                                    <meshMatcapMaterial color={'green'} />
                                                          </mesh> 
                                                        </>
                                                      }
                                            
                                            
                                          </group>
                                          <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'} _speed={1} _number={30} x={0} z={0} />
                                          </>
          }
          
          {props.skin == "wall_1" && <mesh ref={itemRef}  geometry={nodes.wall_1.geometry} material={mat} position={[0,0,0]}/>}
      </group>
      
      </>
            
      
  )
}

export function ItemType1Model(props)
{
  //GERE LES UTEMS SPRITE SUR LA MAP Y COMPRIS LES ITEMS QUE LES MOBS
  let _appContext = useContext(appContext)
  let paticleTexture;
  let spriteRef = useRef(null);
  let passedTime = 0;

  if(props.skin == 'coin_item_1')
  {
    paticleTexture = useTexture('coin.svg');
  }

  useEffect(()=>
    { 
      
      props.controller.itemController.value[props.controller.index] = (args,params)=>
      {
       
          if(args == 'SHOW-ITEM')
          {
              spriteRef.current.visible = true;
          }
          else if(args == 'REMOVE-ITEM')
          {
              spriteRef.current.visible = false;
          }
          else if(args == 'MOVE-ITEM')
          {
            
            spriteRef.current.position.x = params.x
            spriteRef.current.position.z = params.z
          }
      } 
    },[])
  useFrame((clock)=>
    {
        if(!_appContext.gamePause.current)
        {passedTime += 1/40;
        spriteRef.current.children[0].position.y += Math.sin(passedTime)/400;}
    })
  return(     <>
              <group ref={spriteRef} visible={props._visible} position={[props.x,0.5,props.z]} >
                    <sprite 
                      position={[0,0,0]} scale={[0.4,0.4,1]}
                    >
                      <spriteMaterial map={paticleTexture}   />
                      
                    </sprite>
                    <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'}  _speed={1} _number={15} x={0} z={0} />
              </group>
              </>
  )
}
function CustomParticle(props)
{
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let paticleTexture = useTexture(`particleRes/${props._skin}`);
  let objRef = useRef(null);
  let pointRef = useRef(null)
  let particlesContainer =[];
  let particlesInfo = [];

      for(let i =0;i<props._number;i++)
      {
        particlesInfo[i] = {start:false,timer:Math.floor(Math.random()*80),limit:1.1}
        particlesInfo[i].start = particlesInfo[i].timer ==0? true : false
        particlesContainer[i] = <sprite key={i} 
                                  position={[(Math.random()*0.9)-0.5
                                    ,0
                                    ,(Math.random()*0.9)-0.5]} scale={Math.random()*props._size}
                                >
                                  <spriteMaterial visible={false} color={props._color} alphaMap={paticleTexture} depthWrite={true}  />
                                </sprite>
      }  
  
  useFrame(()=>
    { 
      if(!_appContext.gamePause.current)
      
      {
          for(let i =0;i<pointRef.current.children.length;i++)
          {
            if(particlesInfo[i].start)
            {
              pointRef.current.children[i].position.y += 0.01*props._speed;
              pointRef.current.children[i].material.visible = true
              if(pointRef.current.children[i].position.y >= particlesInfo[i].limit )
              {
                particlesInfo[i].start = false;
                particlesInfo[i].timer = Math.floor(Math.random()*80);
                let scaleValue = Math.random()*props._size
                pointRef.current.children[i].scale.set(scaleValue,scaleValue,scaleValue)
                pointRef.current.children[i].material.visible = false;
                pointRef.current.children[i].position.y = 0;
              }
              
            }
            else
            {
              particlesInfo[i].timer --;
              if(particlesInfo[i].timer<=0)
              {
                particlesInfo[i].start = true;
              }
            }
            
          }
      }
      
    })
  return(
        <group
          name='PARTICLE GROUP CONTAINER'
          position={[props.x,0.2,props.z]}
          ref={pointRef}
        >
            {particlesContainer}
        </group>
  )
}

export function ExitDoor_model(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let texturemat = prepareTexture('txtglobal1.jpg');

  let faceRef = useRef(null)
  let mat_0 = new THREE.MeshBasicMaterial({map:texturemat});

let mat = new THREE.ShaderMaterial( {
  uniforms: THREE.UniformsUtils.merge( [
      THREE.UniformsLib[ 'fog' ],{utime:{value:0.2},uColor:{value:new THREE.Vector3(1,0,0)}}] ),
    vertexShader: vertex,
    fragmentShader: frags,
    fog: true,
    transparent:true,
    side:THREE.DoubleSide
  } );
  useFrame((clock)=>{
    faceRef.current.material.uniforms.utime.value += 0.05;

  })

  useEffect(()=>
    { 
      if(props.isOpen)
      {
        faceRef.current.material.uniforms.uColor.value.x = 0.0;
        faceRef.current.material.uniforms.uColor.value.z = 1.0;
      }
      props.controller.exitDoorController.value[props.controller.index] = (args)=>
      {
          if(args == 'OPEN-DOOR')
          {
            faceRef.current.material.uniforms.uColor.value.x = 0.0;
            faceRef.current.material.uniforms.uColor.value.z = 1.0;
          }
      } 
    },[])
  return(
    
    // <mesh geometry={nodes.door_1.geometry} material={mat_0} position={[props.x,0,props.z]}>
    //         <mesh ref={faceRef} geometry={nodes.door_1_face1.geometry} material={mat} position={[0, 1.018, -0.746]} rotation={[-Math.PI / 2, 0, 0]} scale={[0.746, 1, 0.892]} />
    //         <mesh geometry={nodes.door_1_face2.geometry} material={mat} position={[0.752, 1.018, 0.005]} rotation={[0, 0, -Math.PI / 2]} scale={[0.862, 1, 0.75]} />
    //         <mesh geometry={nodes.door_1_face3.geometry} material={mat} position={[-0.748, 1.018, 0.005]} rotation={[-Math.PI, 0, Math.PI / 2]} scale={[0.862, 1, 0.75]} />
    //         <mesh geometry={nodes.door_1_face4.geometry} material={mat} position={[0, 1.018, 0.754]} rotation={[-Math.PI / 2, Math.PI / 2, 0]} scale={[0.862, 1, 0.761]} />
    // </mesh>
    <mesh name="ndoor" geometry={nodes.ndoor.geometry} material={mat_0} position={[props.x,0,props.z]}>
            <mesh ref={faceRef} name="door_1_face1" geometry={nodes.door_1_face1.geometry} material={mat} position={[-0.01, 1.132, -0.693]} rotation={[-Math.PI / 2, Math.PI / 2, 0]} scale={[0.862, 1, 0.761]} />
            <mesh name="door_1_face2" geometry={nodes.door_1_face2.geometry} material={mat} position={[0.705, 1.137, 0.008]} rotation={[0, 0, -Math.PI / 2]} scale={[0.862, 1, 0.75]} />
            <mesh name="door_1_face3" geometry={nodes.door_1_face3.geometry} material={mat} position={[-0.72, 1.119, 0.024]} rotation={[-Math.PI, 0, Math.PI / 2]} scale={[0.862, 1, 0.75]} />
            <mesh name="door_1_face4" geometry={nodes.door_1_face4.geometry} material={mat} position={[-0.008, 1.138, 0.736]} rotation={[-Math.PI / 2, Math.PI / 2, 0]} scale={[0.862, 1, 0.761]} />
    </mesh>

    
  )
}

export function Mob_1_model(props) {

  const group = React.useRef()
  const { nodes, materials, animations } = useGLTF('/model.glb')
  const { mixer,actions } = useAnimations(animations, group)
  
  let _appContext = useContext(appContext);
  let _mobContext = useContext(props._context);
  const mat = new THREE.MeshMatcapMaterial({color:'red',transparent:true})
  let modelRef = useRef(null);
  let mobHitManager = {startEffect:false,timer:10,effectCount:0}
  let passedTime = 0;
  let mobShakeFromLeft = false;
  let mobInitialPos = 0;
  let mobShakeAnimationStart = false;
  let explodeParticleController = useRef(null); 
  let shakeOrientation = useRef('FRONT-BACK');
  let animationManager = useRef({start:false});
  let handRef = useRef(null);
  let customMobController = useRef(null);
  let shakeBrick = ()=>
    { 
      let value = mobShakeFromLeft? -0.2 : 0.2;
      mobShakeFromLeft = mobShakeFromLeft? false : true;
      if(shakeOrientation.current == 'FRONT-BACK')
      {
        modelRef.current.position.x = modelRef.current.position.x + value
      }
      else
      {
        modelRef.current.position.z = modelRef.current.position.z + value
      }
      
    }
  let shakeBrickCallBack = ()=>
    { 
      
      if(shakeOrientation.current == 'FRONT-BACK')
      {modelRef.current.position.x = mobInitialPos}
      else
      {modelRef.current.position.z = mobInitialPos}
      mobShakeAnimationStart = false;
    }
  useFrame(()=>
    {
      if(!_appContext.gamePause.current)
      { 
        if(animationManager.current.start)
        {
            if(actions.m_mob1attack2?.time >= 0.4)
            {
              animationManager.current.start = false;
              _mobContext.mobShootAnimationOver.current = true;
            }
            if(actions.m_mob1dead1?.time >= 0.3)
            {
             
              actions.m_mob1dead1.paused = true;
              actions.m_mob1dead2.paused = true;
              actions.m_mob1dead3.paused = true;
              actions.m_mob1dead4.paused = true;
              actions.m_mob1dead5.paused = true;
              animationManager.current.start = false;
            }
        }

        passedTime += 1/40;
        modelRef.current.position.y += Math.sin(passedTime)/400;

        if(mobHitManager.startEffect)
          {
            mobHitManager.timer--;
            if(mobHitManager.timer == 0)
            {
              mobHitManager.effectCount ++;
              mobHitManager.timer = 10;
              
              if(mobHitManager.effectCount<7)
              { 
                modelRef.current.children[0].visible = modelRef.current.children[0].visible? false : true;
              }
              else
              {
                mobHitManager.effectCount = 0;
                mobHitManager.startEffect = false;
                modelRef.current.children[0].visible = false;
              }
              
            }
          }
      }
    })
    let mobAttackAnime = ()=>
      {
        animationManager.current.start = true;
        actions.m_mob1attack1?.play();
        actions.m_mob1attack2?.play();
        actions.m_mob1attack3?.play();
        actions.m_mob1attack4?.play();
        actions.m_mob1attack5?.play();
      }

  useEffect(()=>
    {
      if(props.customModel == 'none')
      {
        actions.m_mob1attack1?.setLoop(THREE.LoopOnce,1);
        actions.m_mob1attack2?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1attack3?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1attack4?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1attack5?.setLoop(THREE.LoopOnce,1)
  
        actions.m_mob1dead1?.setLoop(THREE.LoopOnce,1);
        actions.m_mob1dead2?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1dead3?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1dead4?.setLoop(THREE.LoopOnce,1)
        actions.m_mob1dead5?.setLoop(THREE.LoopOnce,1)
      }


      mixer.addEventListener('finished', function( e ) 
      {
        if(e.action._clip.name == "m_mob1attack2")
        {
          actions.m_mob1attack1?.stop();
          actions.m_mob1attack2?.stop();
          actions.m_mob1attack3?.stop();
          actions.m_mob1attack4?.stop();
          actions.m_mob1attack5?.stop();
          
        }
        else if(e.action._clip.name == "m_mob1dead1")
        {
          actions.m_mob1dead1?.stop();
          actions.m_mob1dead2?.stop();
          actions.m_mob1dead3?.stop();
          actions.m_mob1dead4?.stop();
          actions.m_mob1dead5?.stop();
          
        }

        
      } )
        
    },[])
  useEffect(()=>
    {
      /**
       * 
       * @param {string} args 
       * @param {object|undefined} params 
       */
      _mobContext.enemyController.current = (args,params)=>
        {
          if(args == 'REMOVE-MOB')
          {
            modelRef.current.visible = false;
          }
          else if(args == 'MOVE-MOB')
          {
            modelRef.current.position.x = params.x
            modelRef.current.position.z = params.z
          }
          else if(args == 'MOB-TOUCHED')
          { 
            if(!mobShakeAnimationStart)
            {
              explodeParticleController.current('EXPLODE')
              mobShakeAnimationStart = true
             
              if(shakeOrientation.current == 'FRONT-BACK')
              {mobInitialPos = modelRef.current.position.x;}
              else
              {mobInitialPos = modelRef.current.position.z;}
              let customCounter = new CustomCounter(4,7,shakeBrick,shakeBrickCallBack)
              customCounter.start();
            }

          }
          else if(args == 'MOB-ROTATE-LEFT')
          {
            shakeOrientation.current = 'LEFT-RIGHT'
            modelRef.current.rotation.y = Math.PI*0.5
          }
          else if(args == 'MOB-ROTATE-RIGHT')
          {
            shakeOrientation.current = 'LEFT-RIGHT'
            modelRef.current.rotation.y = -Math.PI*0.5
          }
          else if(args == 'MOB-ROTATE-FRONT')
          {
            shakeOrientation.current = 'FRONT-BACK'
            modelRef.current.rotation.y = 0
          }
          else if(args == 'MOB-ROTATE-BACK')
          {
            shakeOrientation.current = 'FRONT-BACK'
            modelRef.current.rotation.y = Math.PI
          }
          else if(args == 'PLAY-MOB-ATTACK-ANIMATION')
          {
            if(props.customModel == 'none')
            {
              mobAttackAnime()
            }
          
          }
          else if(args == 'PLAY-MOB-DEAD-ANIMATION')
          { 
            
            if(props.customModel == 'none')
            {
                let customCounter = new CustomCounter(5,0,()=>
                  {
                    
                      handRef.current.material.opacity -=0.1;
                      if(handRef.current.material.opacity<=0)
                        {
                            modelRef.current.visible = false;
                            params()
                            return true
                        }
                      else
                      {
                            return false
                      }
                    
                    
                  },null)
                  customCounter.start();
            }
            else
            {
              customMobController.current('REMOVE-MOB');
              params();
            }
            
            
          }
        }
    },[])
  
  return (

        

          <>  <MobModelContext.Provider value={{customMobController}}>
                    <group ref={group} {...props} dispose={null}>
                    <mesh ref={modelRef} position={[props.x,0.8,props.z]} rotation={[0,Math.PI, 0]} >
                            <boxGeometry args={[2,2,2]} />
                            <meshBasicMaterial color={'red'} visible={false} wireframe />
                            <MobHitParticleEffect controller={explodeParticleController} x={0.5} z={0.5} />
                            {/* MOB MODEL */}
                            {props.customModel == 'none'?
                              <>
                                  <mesh name="nmob1" geometry={nodes.nmob1.geometry} material={new THREE.MeshMatcapMaterial({color:'black'})} >
                                    <mesh ref={handRef} name="nmob1_hand_l" geometry={nodes.nmob1_hand_l.geometry} material={mat} position={[0.639, -0.473, -0.066]} />
                                    <mesh name="nmob1_hand_r" geometry={nodes.nmob1_hand_r.geometry} material={mat} position={[-0.639, -0.494, 0]} />
                                    <mesh name="nmob1head" geometry={nodes.nmob1head.geometry} material={new THREE.MeshMatcapMaterial({color:'white'})} />
                                    <mesh name="nmob1horn" geometry={nodes.nmob1horn.geometry} material={mat} />
                                  </mesh>
                              </>
                              :
                              <>
                              <group ref={handRef}>
                                  {props.customModel}
                              </group>
                              
                              </>
                            }
                            

                    </mesh>
                    
                    <mesh position={[props.x,0.1,props.z]} visible={false}
                    >
                        <boxGeometry args={[2,2,2]}  />
                        <meshBasicMaterial wireframe color={'red'} />
                        <BulletCollisionEffect />
                    </mesh>
                    </group>
              </MobModelContext.Provider>
          </>
         
            
      
  )
}
function MobHitParticleEffect(props)
{
  let paticleTexture = useTexture('particleRes/fire_01.png')
  let spriteGroupRef = useRef(null)
  let ref1 = useRef(null)
  let ref2 = useRef(null)
  let ref3 = useRef(null)
  let ref4 = useRef(null)
  let explodeSeepd = 0.03
  let explodeStart = useRef(false);
  let spriteMat = <spriteMaterial color={'red'} alphaMap={paticleTexture} depthWrite={true}  />;
  useFrame(()=>
    {
      if(explodeStart.current)
      {
        ref1.current.position.x += explodeSeepd
        ref1.current.position.y += explodeSeepd
        ref2.current.position.x -= explodeSeepd
        ref2.current.position.y += explodeSeepd

        ref3.current.position.x += explodeSeepd
        ref3.current.position.y -= explodeSeepd
        ref4.current.position.x -= explodeSeepd
        ref4.current.position.y -= explodeSeepd
        
        if(ref1.current.position.x >= 0.5)
        {
          explodeStart.current = false;
          spriteGroupRef.current.visible = false;
          ref1.current.position.x = 0
          ref1.current.position.y = 0.2
          ref2.current.position.x = -0.2
          ref2.current.position.y = 0.2

          ref3.current.position.x = 0
          ref3.current.position.y = 0
          ref4.current.position.x = -0.2
          ref4.current.position.y = 0
        }
      }
        
    })

  useEffect(()=>
    {
      props.controller.current = (args)=>
        {
          if(args == 'EXPLODE')
          {
            spriteGroupRef.current.visible = true;
            explodeStart.current = true;
          }
        }  
    },[])
  return(
    <>
        <group
         ref={spriteGroupRef} visible={false}
        >
                <sprite 
                  ref={ref1}
                  position={[0,0.2,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>
                <sprite 
                  ref={ref2}
                  position={[-0.2,0.2,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>

                <sprite 
                  ref={ref3}
                  position={[0,0,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>
                <sprite 
                  ref={ref4}
                  position={[-0.2,0,0.7]} scale={0.4}
                >
                  {spriteMat}
                </sprite>
        </group>
        
        
    </>
    
    
  )
}


export function Barier_Model(props)
{
  let _gameAppContext = useContext(gameAppContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture('txtglobal1.jpg');
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  let particleGroupRef = useRef(null)
  let modelRef = useRef(null);
  let planeRef = useRef(null);

  let modelFunc = (args)=>
      {
          if(args == "hide")
          { 

            
              particleGroupRef.current.visible = true;
              let customCounter = new CustomCounter(100,0,()=>
                {
                   
                    if(props.customModel == 'none')
                    {
                      modelRef.current.material.visible = false;
                      planeRef.current.material.visible = false;
                    }
                    else
                    {
                      modelRef.current.visible = false;
                    }
                   
                   particleGroupRef.current.visible = false;
                   return true;
                },null);
              
              customCounter.start();
            

            
          }
      }
  let mat2 = new THREE.ShaderMaterial( {
    uniforms: THREE.UniformsUtils.merge( [
        THREE.UniformsLib[ 'fog' ],{utime:{value:0.2},uColor:{value:new THREE.Vector3(1,0,0)}}] ),
      vertexShader: vertex,
      fragmentShader: frags,
      fog: true,
      transparent:true,
      side:THREE.DoubleSide
    } );
  useFrame((clock)=>{

    if (props.customModel == 'none')
    {
      planeRef.current.material.uniforms.utime.value += 0.02;
    }  
      

  })
  useEffect(()=>
    {

        for(let i =0;i<_gameAppContext.barierModelIndexArr.value.length;i++)
          {
            if(_gameAppContext.barierModelIndexArr.value[i].objectId == props.refID)
            {
              _gameAppContext.barierModelIndexArr.value[i].modelController = modelFunc;
            }
          }
      
      
      
    },[])
  
  return(     <>
                     {props.customModel == 'none'?
                      <mesh ref={modelRef} name="nbarrier" geometry={nodes.nbarrier.geometry} material={mat} position={[props.x,0,props.z]} rotation={[0,(props.orientation == 'FRONT'?0:Math.PI*0.5),0]} >
                          <mesh ref={planeRef} name="nbarrierplane" geometry={nodes.nbarrierplane.geometry} material={mat2} position={[0.008, 0.912, 0]} rotation={[Math.PI / 2, 0, 0]} />
                      </mesh>
                      :
                      <group ref={modelRef} position={[props.x,0,props.z]} rotation={[0,(props.orientation == 'FRONT'?0:Math.PI*0.5),0]}>
                        {props.customModel}
                      </group>
                     }
                    
                    <group
                          ref={particleGroupRef}
                          visible={false}
                    >
                        <CustomParticle _skin={'smoke_06.png'} _size={1.5} _color={'white'} _speed={3} _number={10} x={props.x} z={props.z} />
                    </group>
              
              </>
  )
}
export function EnemyBullet(props)
{
  let bulletTXT = useTexture('ennemyBulletTxt.png');
  bulletTXT.flipY = false;
  bulletTXT.colorSpace = THREE.SRGBColorSpace; 
  bulletTXT.minFilter = THREE.LinearFilter;
  bulletTXT.magFilter = THREE.LinearFilter;

  return(
          <>
                   <mesh
                        key={props._i}
                        ref={props._ref}
                        position={props._position}
                    >
                        <sphereGeometry args={[0.2,10,10]} />
                        <meshBasicMaterial visible={false} map={bulletTXT} />
                    </mesh>
          </>
  )
}

export function BulletCollisionEffect(props)
{
  return(
    <>
    <sprite 
    position={[0
      ,1
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    <sprite 
    position={[0.16
      ,1
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    <sprite 
    position={[0
      ,0.85
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    <sprite 
    position={[0.16
      ,0.85
      ,-0.7]} scale={0.15}
    >
    <spriteMaterial visible={true} color={'white'} depthWrite={true}  />
    </sprite>
    </>
  )
}
useGLTF.preload('/model.glb')
